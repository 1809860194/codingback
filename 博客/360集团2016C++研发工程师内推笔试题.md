- 内存管理策略
- 静态局部变量只对定义它的函数体始终可见，函数体执行完过后虽然还存在，但是无法被其他的使用
```c++
static int a=1;
void fun1(void){    a=2;  }
void fun2(void){    int a=3;  }
void fun3(void){   static int a=4;  }
int main(int argc,char** args){ 
     printf(“%d”,a); 
     fun1( ); 
     printf(“%d”,a); 
     fun2( ); 
     printf(“%d”，a);
     fun3( );
      printf(“%d”,a); 
}
```
- 函数传参形式
- const 类型的对象能否修改
- fork 产生的进程数（有无缓冲）
```html
	case 后面的常量表达式实际上只起语句标号作用 , 而不起条件判断作用 , 即 " 只是开始执行处的入口标号 ".  因此 , 一旦与 switch 后面圆括号中表达式的值匹配 , 就从此标号处开始执行 , 而且执行完一个 case 后面的语句后 , 若没遇到 break 语句 , 就自动进入 下一个 case 继续执行 , 而不在判断是否与之匹配 , 直到遇到 break 语句才停止执行 , 退出 break 语句 . 因此 , 若想执行一个 case 分之后立即跳出  switch 语句 , 就必须在此分支的最后添加一个 break 语句
```

- - 数二进制中 1 的位数
- 宏的展开
```c++
structA{
   unsigned int a; //对于开始连续的第一个8字节内存，a占4字节 
   char b[2];      //b[]占1*2字节，在a后的连续2字节内存放，还剩2个字节，
   double c;       //c占8字节，第一个8字节还剩2字节不足以存放c,自动补充该2字节。并同时开辟第二个8字节内存存放c
   short d;        //d占2字节，开辟第三个8字节，存放d。剩余的6个字节补齐。故总共开辟了8*3=24字节存放该数据结构
}
```
- 前缀 ++ 和后缀 ++
- 指针，传地址，对形参的操作就是对实参的操作；
- 引用，形参作为实参的别名，实质也是对实参的操作；
- 传值，若没有返回操作，对形参的操作不会引起实参的变化。

```html
	有关动态分配和静态分配：
所谓动态内存分配就是指在程序执行的过程中动态地分配或者回收存储空间的分配内存的方法。动态内存分配不象数组等静态内存分配方法那样需要预先分配存储空间，而是由系统根据程序的需要即时分配，且分配的大小就是程序要求的大小。例如我们定义一个float型数组：float score[100]; 但是，在使用数组的时候，总有一个问题困扰着我们：数组应该有多大？在很多的情况下，你并不能确定要使用多大的数组，比如上例，你可能并不知道我们要定义的这个数组到底有多大，那么你就要把数组定义得足够大。这样，你的程序在运行时就申请了固定大小的你认为足够大的内存空间。即使你知道你想利用的空间大小，但是如果因为某种特殊原因空间利用的大小有增加或者减少，你又必须重新去修改程序，扩大数组的存储范围。这种分配固定大小的内存分配方法称之为静态内存分配。但是这种内存分配的方法存在比较严重的缺陷，特别是处理某些问题时：在大多数情况下会浪费大量的内存空间，在少数情况下，当你定义的数组不够大时，可能引起下标越界错误，甚至导致严重后果。
	我们用动态内存分配就可以解决上面的问题. 所谓动态内存分配就是指在程序执行的过程中动态地分配或者回收存储空间的分配内存的方法。动态内存分配不象数组等静态内存分配方法那样需要预先分配存储空间，而是由系统根据程序的需要即时分配，且分配的大小就是程序要求的大小。从以上动、静态内存分配比较可以知道动态内存分配相对于静态内存分配的特点：
1、不需要预先分配存储空间；

2、分配的空间可以根据程序的需要扩大或缩小。

     说白了，内存的静态分配和动态分配的区别主要是两个：
       一是时间不同。静态分配发生在程序编译和连接的时候。动态分配则发生在程序调入和执行的时候。
      二是空间不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由函数alloca（）进行分配。不过栈的动态分配和堆不同，他的动态分配是由编译器进行释放，无需我们手工实现。    

       对于一个进程的内存空间而言，可以在逻辑上分成3个部份：代码区，静态数据区和动态数据区。动态数据区一般就是“堆栈”。“栈(stack)”和“堆(heap)”是两种不同的动态数据区，栈是一种线性结构，堆是一种链式结构。进程的每个线程都有私有的“栈”，所以每个线程虽然代码一样，但本地变量的数据都是互不干扰。一个堆栈可以通过“基地址”和“栈顶”地址来描述。全局变量和静态变量分配在静态数据区，本地变量分配在动态数据区，即堆栈中。程序通过堆栈的基地址和偏移量来访问本地变量。

        一般，用static修饰的变量，全局变量位于静态数据区。函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放
```
- strcpy执行时，会自动在字符串后面添加上"\0"

```c++
i = ++a || ++b || ++c;
```
```html
	右边的表达式为关系表达式，判断为1或0，先执行++a，a=2，因此为true，或操作的前部分为true时，后面不再执行，因此第一个和第二个“或”操作后面都不再执行。因此i  = 1, a = 2. b和c不变。
```